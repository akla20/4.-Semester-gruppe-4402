/*********
  Version: 6
  Date: 10.05.22
  Update: This is a one track version of the twoway communication code.
  The code is written to gain the time from the central unit and send back data if "SEND" is written.
  The variables have been changed to more logical names and comments have been added and done to set up 4 fsr sensors, so 4 lines for the runner in one end. 
  Author: 4402
*********/

#include <esp_now.h>
#include <WiFi.h>

//The mac address of the central unit (The Master)
//uint8_t broadcastAddress[] = {0x08, 0x3A, 0xF2, 0x45, 0x43, 0x9C}; // Jacob TTGO
uint8_t broadcastAddress[] = {0x08, 0x3A, 0xF2, 0x45, 0x42, 0xC4}; // Nikolaj TTGO
//uint8_t broadcastAddress[] = {0x24, 0x6F, 0x28, 0x0B, 0x6E, 0xFC}; // Jacob NodeMCU
//uint8_t broadcastAddress[] = {0xAC, 0x67, 0xB2, 0x28, 0xCF, 0x08}; // Nikolaj Node MCU 2

//Initialise the needed variables and flags
unsigned long TimerBegin, Time, Running_time,SendTime;
bool enkelt_start = true;
bool enkelt_stop = false;
bool start_flag = false;
//bool sensor_skifte_flag;

String success;

//Needed for two way communication
esp_now_peer_info_t peerInfo;

/*
  //Initialise the message to be recived from the periferials (MUST MATCH THEIR NAME IN THEIR CODE)
  typedef struct struct_arrivaltime {
  float arrival_time;
  float departure_time;
  bool sensor_skifte_flag;
  } struct_arrivaltime;
*/
//Initialise the message to be recived from the periferials (MUST MATCH THEIR NAME IN THEIR CODE)
typedef struct struct_send_data {
  int sensor_identifier = 1;
  float p1_arrival_time;
  float p1_departure_time;
  float p2_arrival_time;
  float p2_departure_time;
  float p3_arrival_time;
  float p3_departure_time;
  float p4_arrival_time;
  float p4_departure_time;
} struct_send_data;


// Create a struct_message to hold incoming sensor readings
struct_send_data senddata;


//Initliase the messege to be send to all perifireals (MUST MATCH THEIR NAME IN THEIR CODE)
typedef struct struct_initialisetime {
  bool starter;
} struct_initialisetime;

struct_initialisetime NewTime;

//callback function that will be executed when data is received
void OnDataRecv(const uint8_t * mac, const uint8_t *incomingData, int len) {
  memcpy(&NewTime, incomingData, sizeof(NewTime));
  Serial.println("Started");
  //Serial.print("Bytes received: ");
  //Serial.println(len);
}

// Callback when data is sent
void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  Serial.print("\r\nLast Packet Send Status:\t");
  Serial.println(status == ESP_NOW_SEND_SUCCESS ? "Delivery Success" : "Delivery Fail");
  if (status == 0) {
    success = "Delivery Success :)";
  }
  else {
    success = "Delivery Fail :(";
  }
}

///////// FSR KODE //////////

#define FORCE_SENSOR_P1 A0
#define FORCE_SENSOR_P2 A3
#define FORCE_SENSOR_P3 A6
#define FORCE_SENSOR_P4 A4

unsigned long P1_newSample, P1_oldSample;
unsigned long P2_newSample, P2_oldSample;
unsigned long P3_newSample, P3_oldSample;
unsigned long P4_newSample, P4_oldSample;

unsigned long arrival_time, departure_time;

int Threshold = 100;

int i = 0;
unsigned long delaytime = 2000;

///////// FSR KODE //////////


//Hele arrayet i millis med tolerancer
int Beeb_array_with_tollerance [] = {9320, 17790, 26260, 34730, 43200, 51670, 60140, 68610, //Level 1
                                     76560, 84560, 92560, 100560, 108560, 116560, 124560, 132560, //Level 2
                                     140100, 147680, 155260, 162840, 170420, 178000, 185580, 193160, //Level 3
                                     200320, 207520, 214720, 221920, 229120, 236320, 243520, 250720, 257920, //Level 4
                                     264750, 271610, 278470, 285330, 292190, 299050, 305910, 312770, 319630, //Level 5
                                     326150, 332700, 339250, 345800, 352350, 358900, 365450, 372000, 378550, 385100, //Level 6
                                     391330, 397590, 403850, 410110, 416370, 422630, 428890, 435150, 441410, 447670, //Level 7
                                     453640, 459640, 465640, 471640, 477640, 483640, 489640, 495640, 501640, 507640, 513640, //Level 8
                                     519380, 525140, 530900, 536660, 542420, 548180, 553940, 559700, 565460, 571220, 576980, //Level 9
                                     582490, 588030, 593570, 599110, 604650, 610190, 615730, 621270, 626810, 632350, 637890, //Level 10
                                     643200, 648530, 653860, 659190, 664520, 669850, 675180, 680510, 685840, 691170, 696500, 701830, //Level 11
                                     706950, 712090, 717230, 722370, 727510, 732650, 737790, 742930, 748070, 753210, 758350, 763490, //Level 12
                                     768450, 773420, 778390, 783360, 788330, 793300, 798270, 803240, 808210, 813180, 818150, 823120, 828090, //Level 13
                                     832870, 837670, 842470, 847270, 852070, 856870, 861670, 866470, 871270, 876070, 880870, 885670, 890470, //Level 14
                                     895110, 899760, 904410, 909060, 913710, 918360, 923010, 927660, 932310, 936960, 941610, 946260, 950910, //Level 15
                                     955390, 959890, 964390, 968890, 973390, 977890, 982390, 986890, 991390, 995890, 1000390, 1004890, 1009390, 1013890, //Level 16
                                     1018240, 1022600, 1026960, 1031320, 1035680, 1040040, 1044400, 1048760, 1053120, 1057480, 1061840, 1066200, 1070560, 1074920, //Level 17
                                     1079140, 1083380, 1087620, 1091860, 1096100, 1100340, 1104580, 1108820, 1113060, 1117300, 1121540, 1125780, 1130020, 1134260, 1138500, //Level 18
                                     1142600, 1146710, 1150820, 1154930, 1159040, 1163150, 1167260, 1171370, 1175480, 1179590, 1183700, 1187810, 1191920, 1196030, 1200140, //Level 19
                                     1204130, 1208130, 1212130, 1216130, 1220130, 1224130, 1228130, 1232130, 1236130, 1240130, 1244130, 1248130, 1252130, 1256130, 1260130, 1264130, //Level 20
                                     1268010, 1271900, 1275790, 1279680, 1283570, 1287460, 1291350, 1295240, 1299130, 1303020, 1306910, 1310800, 1314690, 1318580, 1322470, 1326360 //Level 21
                                    };





void setup() {
  //Initialize Serial Monitor
  Serial.begin(115200);

  //Set device as a Wi-Fi Station
  WiFi.mode(WIFI_STA);

  //Init ESP-NOW
  if (esp_now_init() != ESP_OK) {
    Serial.println("Error initializing ESP-NOW");
    return;
  }
  esp_now_register_send_cb(OnDataSent);

  peerInfo.channel = 0;
  peerInfo.encrypt = false;

  // register central unit as a peer
  memcpy(peerInfo.peer_addr, broadcastAddress, 6);
  if (esp_now_add_peer(&peerInfo) != ESP_OK) {
    Serial.println("Failed to add peer");
    return;
  }

  // Once ESPNow is successfully Init, we will register for recv CB to
  // get recv packer info
  esp_now_register_recv_cb(OnDataRecv);

}

void loop() {

  //The different functions to be called depending on the input from the central unit
  if (NewTime.starter == true && enkelt_start == true) {
    //delay(6681); // M5-Stack delay for beep,beep,beep BEEP
    TimerBegin = millis(); // New time baseline
    Serial.println("Test started");
    enkelt_start = false;
    enkelt_stop = true;
    start_flag = true;
    
    if (P1_newSample > Threshold){
    i = 0;
    }
    else{
      i = 1;
    }
  }

  if (NewTime.starter == false && enkelt_stop == true) {
    Serial.println("Test stopped");
    enkelt_start = true;
    enkelt_stop = false;

  }

// Sends data after each shuttle
Time = millis();
Running_time = Time - TimerBegin;
if (Running_time > delaytime){
SendTime = Running_time-delaytime;
}

if(SendTime >= Beeb_array_with_tollerance [i] & start_flag == true){
Serial.print("Running_time: ");
Serial.println(Running_time);
Serial.print("SendeTime:");
Serial.println(SendTime);
esp_err_t result = esp_now_send(0, (uint8_t *) &senddata, sizeof(struct_send_data));
i++;
Serial.print("i: ");
Serial.println(i);
Serial.println("SEND");
}


  ///////// FSR KODE //////////

  // PARTICIPANT 1

  P1_oldSample = P1_newSample;
  P1_newSample = analogRead(FORCE_SENSOR_P1);
  //Serial.print(P1_newSample);
  //Serial.print(" ");

  // PARTICIPANT 2

  P2_oldSample = P2_newSample;
  P2_newSample = analogRead(FORCE_SENSOR_P2);
  //Serial.print(P2_newSample);
  //Serial.print(" ");

  // PARTICIPANT 3

  P3_oldSample = P3_newSample;
  P3_newSample = analogRead(FORCE_SENSOR_P3);
  //Serial.print(P3_newSample);
  //Serial.print(" ");


  // PARTICIPANT 4

  P4_oldSample = P4_newSample;
  P4_newSample = analogRead(FORCE_SENSOR_P4);
  //Serial.println(P4_newSample);


  // PARTICIPANT 1

  if (P1_oldSample <= Threshold && P1_newSample > Threshold)
  {
    arrival_time = millis();
    senddata.p1_arrival_time =  arrival_time - TimerBegin;
    //senddata.sensor_identifier = 1; // The one of two differences from the other peripheral code
    //esp_err_t result = esp_now_send(0, (uint8_t *) &senddata, sizeof(struct_send_data));
    /*
    Serial.print("Sensor: ");
    Serial.println(senddata.sensor_identifier);
    Serial.println("Participant 1");
    Serial.print("Arrival_time: ");
    Serial.println(senddata.p1_arrival_time);
    */
  }

  else if (P1_oldSample >= Threshold && P1_newSample < Threshold)
  {
    departure_time = millis();
    senddata.p1_departure_time =  departure_time - TimerBegin;
    //senddata.sensor_identifier = 1;
    //esp_err_t result = esp_now_send(0, (uint8_t *) &senddata, sizeof(struct_send_data));
    /*
    Serial.print("Departure_time: ");
    Serial.println(senddata.p1_departure_time);
    */
  }

  // PARTICIPANT 2


  if (P2_oldSample <= Threshold && P2_newSample > Threshold)
  {
    arrival_time = millis();
    senddata.p2_arrival_time =  arrival_time - TimerBegin;
    //senddata.sensor_identifier = 1; // The one of two differences from the other peripheral code
    //esp_err_t result = esp_now_send(0, (uint8_t *) &senddata, sizeof(struct_send_data));
    /*
    Serial.print("Sensor: ");
    Serial.println(senddata.sensor_identifier);
    Serial.println("Participant 2");
    Serial.print("Arrival_time: ");
    Serial.println(senddata.p1_arrival_time);
    */
  }

  else if (P2_oldSample >= Threshold && P2_newSample < Threshold)
  {
    departure_time = millis();
    senddata.p2_departure_time =  departure_time - TimerBegin;
    //senddata.sensor_identifier = 1;
    //esp_err_t result = esp_now_send(0, (uint8_t *) &senddata, sizeof(struct_send_data));
    /*
    Serial.print("Departure_time: ");
    Serial.println(senddata.p1_departure_time);
    */
  }

  // PARTICIPANT 3

  if (P3_oldSample <= Threshold && P3_newSample > Threshold)
  {
    arrival_time = millis();
    senddata.p3_arrival_time =  arrival_time - TimerBegin;
    //senddata.sensor_identifier = 1; // The one of two differences from the other peripheral code
    //esp_err_t result = esp_now_send(0, (uint8_t *) &senddata, sizeof(struct_send_data));
    /*
    Serial.print("Sensor: ");
    Serial.println(senddata.sensor_identifier);
    Serial.println("Participant 3");
    Serial.print("Arrival_time: ");
    Serial.println(senddata.p3_arrival_time);
    */
  }

  else if (P3_oldSample >= Threshold && P3_newSample < Threshold)
  {
    departure_time = millis();
    senddata.p3_departure_time =  departure_time - TimerBegin;
    //senddata.sensor_identifier = 1;
    //esp_err_t result = esp_now_send(0, (uint8_t *) &senddata, sizeof(struct_send_data));
    /*
    Serial.print("Departure_time: ");
    Serial.println(senddata.p1_departure_time);
    */
  }

  // PARTICIPANT 4

  if (P4_oldSample <= Threshold && P4_newSample > Threshold)
  {
    arrival_time = millis();
    senddata.p4_arrival_time =  arrival_time - TimerBegin;
    //senddata.sensor_identifier = 1; // The one of two differences from the other peripheral code
    //esp_err_t result = esp_now_send(0, (uint8_t *) &senddata, sizeof(struct_send_data));
    /*
    Serial.print("Sensor: ");
    Serial.println(senddata.sensor_identifier);
    Serial.println("Participant 4");
    Serial.print("Arrival_time: ");
    Serial.println(senddata.p3_arrival_time);
    */
  }

  else if (P4_oldSample >= Threshold && P4_newSample < Threshold)
  {
    departure_time = millis();
    senddata.p4_departure_time =  departure_time - TimerBegin;
    //senddata.sensor_identifier = 1;
    //esp_err_t result = esp_now_send(0, (uint8_t *) &senddata, sizeof(struct_send_data));
    /*
    Serial.print("Departure_time: ");
    Serial.println(senddata.p1_departure_time);
    */
  }

  ///////// FSR KODE //////////

  delay(10);

}
